
interface RequestOptions<Path, Query, Body> {
  headers?: Record<string, string>;
  token?: string;
  permissions?: string;
  params?: Path & Query;
  body?: Body;
}

interface ServiceClientOptions {
  stage?: string;
}

class ServiceClient {

  private stage: string;

  constructor(options?: ServiceClientOptions) {
    const stage = options?.stage ?? process?.NODE_ENV;
    if (!stage) {
      throw new Error("cannot determine stage");
    }
    this.stage = stage;
  }

  /**
   * Replace the path parameters from params object and use the
   * rest as query parameters. This method throws if there are
   * missing path parameters.
   */
  private build_url(route_template: string, params: any): string {
    // replace path variables with param values
    const used = new Set<string>();
    const route = route_template.replace(/{[^}]*}/g, (param) => {
      const name = param.slice(1, -1);
      if (!params.hasOwnProperty(name)) {
        throw new Error(`missing path parameter: '${name}'`);
      }
      used.add(name);
      return encodeURIComponent(params[name]);
    });
    // attach the route to the base url on the appropritate stage
    let url = `https://api.compassdigital.org/${this.stage}${route}`;
    // add remaining parameters to query
    const query: string[] = [];
    for (const [name, value] of Object.entries(params)) {
      if (!used.has(name) && value !== undefined) {
        query.push(`${encodeURIComponent(name)}=${encodeURIComponent(value as any)}`);
      }
    }
    if (query.length > 0) {
      url += "?" + query.join("&");
    }
    return url;
  }

  private async request(method: string, route: string, options: RequestOptions<any, any, any> = {}): Promise<any> {
    const url = this.build_url(route, options.params ?? {});
    const headers = options.headers ?? {};
    if (options.token) {
         headers["Authorization"] = `Bearer ${options.token}`;
    }
    const req: RequestInit = {
      method: method,
      headers: options.headers,
    }
    if (options.body) {
      req.body = JSON.stringify(options.body);
    }
    const res = await fetch(url, req);
    if (!res.ok) {
         throw new Error(await res.text());
    }
    return res.json();
  }

<% for (const {name, method, path, pathT, queryT, bodyT, responseT} of methods) { %>
  <%= name.snake %>(options?: RequestOptions<<%= pathT %>, <%= queryT %>, <%= bodyT %>>): Promise<<%= responseT %>> {
    return this.request("<%= method %>", "<%= path %>", options);
  }
<% } %>
}

